# 排序算法（内部排序，使用内存）
![image](https://github.com/user-attachments/assets/d0194212-7172-4f6a-ad51-f999fc91a6b1)
## 交换排序
### 快速排序
不稳定

1. 选取一个基准pivot，一般为最左元素
2. 从右往左找到比pivot大的值，右值放到左指针位置
3. 接着从左往右找到比其小的值，左值放到右指针位置
4. 重复2,3步骤（为一个循环），直到两指针重合，pivot值放在重合位置，此时基准位置确定
5. 递归左右集合至排序完成

> 平均与最好时间复杂度为O(nlogn)，空间复杂度为O(1)
> 为防止出现最坏情况O(n^2)退化为冒泡排序，会采用随机取pivot或三数取中

### 冒泡排序
**稳定排序**

比较两个元素，使得一轮后最大的元素在最右端，不断重复即可
> 反序->最差时复O(n^2)，平均时复n^2，正序->最好时复O(n)

## 选择排序
### 简单选择排序
不稳定

每次选择最小（最大）的元素，放在最后，重复至排序完成

> 时复O(n^2)

### 堆排序
不稳定

大顶堆输出升序，小顶堆输出降序序列

1. 将根节点（最大最小值）与最后一个叶结点交换，输出该最值
2. 去除最值后重新构成大（小）根堆
3. 重复步骤输出全部值

> 时间复杂度最好最坏都是O(nlogn)，其中构建堆时间复杂度O(n)


## 插入排序
### 直接插入排序
**稳定排序**

> 最好O(n)，最坏或平均O(n^2)

### 希尔排序
不稳定

间隔不断减小的插入排序

> 时间复杂度最差O(n^2)，最好O(nlogn)，平均不定

## 归并排序
**稳定排序**

1. 拆分成一个元素一个元素的
2. 两两合并

> 最差最好平均都为O(nlogn)，**空间复杂度为O(n)**


<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>StudyAllDay</title><link>https://lqh-dlut.github.io/passion</link><description>hello</description><copyright>StudyAllDay</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://lqh-dlut.github.io/passion</link></image><lastBuildDate>Wed, 31 Jul 2024 13:40:35 +0000</lastBuildDate><managingEditor>StudyAllDay</managingEditor><ttl>60</ttl><webMaster>StudyAllDay</webMaster><item><title>三种树</title><link>https://lqh-dlut.github.io/passion/post/san-zhong-shu.html</link><description>## 红黑树&#13;
**自平衡的二叉搜索树，通过染色，解决AVL树频繁的旋转的问题（染色时复小于旋转）**&#13;
&gt; 二叉搜索树：左子树所有值小于等于根节点，右子树相反；左右子树也是二叉搜索树&#13;
&gt; AVL（自平衡二叉搜索树）：解决二叉搜索树在插入删除操作时可能会导致的O(n)操作，使得操作时复全在O(logn)&#13;
&#13;
**最坏情况下，红黑树的黑色高度至多是红色高度的两倍**&#13;
### 红黑树的规则&#13;
1. 非黑即红&#13;
2. 根节点黑&#13;
3. 叶结点黑 _（全是空节点NULL黑色节点）_&#13;
4. 红点黑父子（不红红）&#13;
5. 任一结点到叶子结点路径上黑色结点的个数相同（黑路同）&#13;
&#13;
左旋转伪代码&#13;
```&#13;
Leftrotation(X)&#13;
#初始Y是X的右节点&#13;
    #确立旋转后X的右节点与X的关系&#13;
    X.right = Y.left  #Y左移到X右，确立子树关系&#13;
    if(Y.left != NIL) #Y有左节点或左子树&#13;
        Y.left.parent = X #Y左父结点指针指向X，确立父结点关系&#13;
    &#13;
    #确立旋转后Y的父结点与Y之间的关系&#13;
    Y.parent = X.parent #确定Y的父结点&#13;
    if(X.parent == NIL) #如果X为根节点&#13;
        Root = Y&#13;
    else if(X.parent.left == X)&#13;
        X.parent.left = Y&#13;
    else if(X.parent.right == X)&#13;
        X.parent.left = Y&#13;
    &#13;
    #确立旋转后X和Y之间的关系&#13;
    Y.left = X&#13;
    X.parent = Y&#13;
```&#13;
&#13;
### 插入的调整方法&#13;
插入的是红色结点，容易破坏的是不红红的性质&#13;
1. 叔红：祖父染红，父叔染黑&#13;
&#13;
2. 叔黑&#13;
&#13;
- 同侧：父染黑，祖父染红，以父为基点进行右（左）旋&#13;
- 异侧：父左（右）旋，子染黑，祖父染红，祖父右（左）旋&#13;
&#13;
### 删除的调整方法&#13;
&gt; 双黑节点：所有经过他的路径都会少一个黑节点&#13;
&#13;
1. 没有孩子节点&#13;
- 红色：直接删除&#13;
- 黑色：&#13;
黑兄弟没有孩子：删除后，父染黑，兄弟红&#13;
黑兄弟只有左孩子：删节点，兄弟左孩子染父色，父染黑，兄弟右旋，父左旋&#13;
黑兄弟只有右孩子：删节点，兄弟染父色，父染黑，父左旋&#13;
黑兄弟左右孩子都红色：删节点，兄弟染父色，父染黑，兄弟右孩子染黑，父左旋&#13;
红兄弟：删节点，兄弟染黑，兄弟左孩子染红，父左旋&#13;
&#13;
2. 只有左（右）结点&#13;
&gt; 由于红黑树的性质，红结点不可能只有左（右）子树，只有左右结点的情况只能是父（要删除的结点）黑子红&#13;
&#13;
孩子的值替换，颜色不变（黑）&#13;
&#13;
3. 有双孩子，中序后继或前驱替换，再判断&#13;
&gt; 一棵全黑的树，则兄弟染红，替换后继的值，前驱节点变红&#13;
&#13;
&#13;
## b树&#13;
**多路平衡搜索树，阶数m为结点孩子个数最大值，为了将大型文件存储在磁盘中，减少访问磁盘的次数**&#13;
### b树的规则&#13;
1. 每个结点最多有m棵子树，即m-1个关键字（m叉树）&#13;
2. 根结点至少两个分支，终端结点至少两个关键字，非根非叶结点至少有ceil(m/2)个分支ceil代表向上取整&#13;
3. 每个结点结构，m个指针，一个关键字个数n，m-1个关键字数据&#13;
4. 各个关键字不相同且左小右大排列&#13;
5. 叶子结点在同一层，代表查询失败的位置&#13;
6. 数据分布在不同层级，查找的时间不稳定&#13;
&#13;
&#13;
&gt; 最低层的非叶结点为终端结点&#13;
&#13;
**b树插入关键是结点的拆分，删除关键是借兄弟借父母**&#13;
&#13;
## b+树&#13;
是b树的变体，在I/O方面更加优秀&#13;
&#13;
### b+树规则&#13;
1. m个关键字对应m个分支&#13;
2. 关键字在不同结点之间可以重复&#13;
3. 最低层的叶子结点包含所有关键字，和指向数据的指针（只有叶子结点有指针）&#13;
4. 叶子节点之间通过指针相互链接&#13;
&#13;
**b树不支持顺序查找，b+支持；b树查询速度不稳定，可在任一层级查到，b+树查询速度稳定，都在叶子结点层查到**&#13;
。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/san-zhong-shu.html</guid><pubDate>Wed, 31 Jul 2024 10:36:44 +0000</pubDate></item><item><title>排序算法</title><link>https://lqh-dlut.github.io/passion/post/pai-xu-suan-fa.html</link><description># 排序算法（内部排序，使用内存）&#13;
![image](https://github.com/user-attachments/assets/d0194212-7172-4f6a-ad51-f999fc91a6b1)&#13;
## 交换排序&#13;
### 快速排序&#13;
不稳定&#13;
&#13;
1. 选取一个基准pivot，一般为最左元素&#13;
2. 从右往左找到比pivot大的值，右值放到左指针位置&#13;
3. 接着从左往右找到比其小的值，左值放到右指针位置&#13;
4. 重复2,3步骤（为一个循环），直到两指针重合，pivot值放在重合位置，此时基准位置确定&#13;
5. 递归左右集合至排序完成&#13;
&#13;
&gt; 平均与最好时间复杂度为O(nlogn)，空间复杂度为O(1)&#13;
&gt; 为防止出现最坏情况O(n^2)退化为冒泡排序，会采用随机取pivot或三数取中&#13;
&#13;
### 冒泡排序&#13;
**稳定排序**&#13;
&#13;
比较两个元素，使得一轮后最大的元素在最右端，不断重复即可&#13;
&gt; 反序-&gt;最差时复O(n^2)，平均时复n^2，正序-&gt;最好时复O(n)&#13;
&#13;
## 选择排序&#13;
### 简单选择排序&#13;
不稳定&#13;
&#13;
每次选择最小（最大）的元素，放在最后，重复至排序完成&#13;
&#13;
&gt; 时复O(n^2)&#13;
&#13;
### 堆排序&#13;
不稳定&#13;
&#13;
大顶堆输出升序，小顶堆输出降序序列&#13;
&#13;
1. 将根节点（最大最小值）与最后一个叶结点交换，输出该最值&#13;
2. 去除最值后重新构成大（小）根堆&#13;
3. 重复步骤输出全部值&#13;
&#13;
&gt; 时间复杂度最好最坏都是O(nlogn)，其中构建堆时间复杂度O(n)&#13;
&#13;
&#13;
## 插入排序&#13;
### 直接插入排序&#13;
**稳定排序**&#13;
&#13;
&gt; 最好O(n)，最坏或平均O(n^2)&#13;
&#13;
### 希尔排序&#13;
不稳定&#13;
&#13;
间隔不断减小的插入排序&#13;
&#13;
&gt; 时间复杂度最差O(n^2)，最好O(nlogn)，平均不定&#13;
&#13;
## 归并排序&#13;
**稳定排序**&#13;
&#13;
1. 拆分成一个元素一个元素的&#13;
2. 两两合并&#13;
&#13;
&gt; 最差最好平均都为O(nlogn)，**空间复杂度为O(n)**&#13;
&#13;
。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/pai-xu-suan-fa.html</guid><pubDate>Thu, 25 Jul 2024 03:09:52 +0000</pubDate></item><item><title>Flask</title><link>https://lqh-dlut.github.io/passion/post/Flask.html</link><description>###视图函数&#13;
```python&#13;
from markupsafe import escape&#13;
&#13;
@app.route('/user/&lt;name&gt;')&#13;
def user_page(name):&#13;
    return f'User: {escape(name)}'&#13;
```&#13;
&#13;
&gt; 注意 用户输入的数据会包含恶意代码，所以不能直接作为响应返回，需要使用 MarkupSafe（Flask 的依赖之一）提供的 escape() 函数对 name 变量进行转义处理，比如把 &lt; 转换成 &amp;lt;。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Flask.html</guid><pubDate>Mon, 08 Jul 2024 13:49:18 +0000</pubDate></item><item><title>Transformer</title><link>https://lqh-dlut.github.io/passion/post/Transformer.html</link><description>- 图像识别 -&gt; **CNN卷积神经网络**&#13;
- NLP自然语言处理 -&gt; **RNN循环神经网络** 解决了seq2seq问题 输入输出语句长短不同&#13;
- Transformer与RNN都保留了**编码和解码**的结构&#13;
## 词嵌入&#13;
- “码”指的大概是 把语言中的形式的不同去除后，剩下的单纯的**语义关系**，其标准有：&#13;
&#13;
1. 数字化&#13;
2. 数值体现语义之间的相对关系&#13;
&#13;
&#13;
&gt; 对token进行数字化的两种极端情况，上述的第一点标准都能实现，但第二点都是极端的错误：&#13;
&#13;
- **tokenizer标记器**（分词器）：每一个token都是不同的ID（一维）&#13;
- **onehot独热编码**：每一个token是二级制中的每一位（n维）&#13;
&#13;
&gt; 矩阵乘法实现词嵌入，编码进潜空间，解码出潜空间&#13;
&#13;
- **潜空间**：没有形式上差别的语义空间，是连续的，因此遇到陌生的情况也能找到对应的值&#13;
&#13;
## Word2Vec（词典）&#13;
&#13;
&gt; 一般的机器学习目标：得到一个模型，模型能够完成任务；**Word2Vec**得到的是嵌入矩阵，得到的是模型的参数&#13;
&#13;
- Word2Vec**不需要激活函数**，隐藏层输出层的神经元做的就是向量求和与分解，没有非线性的需求&#13;
&#13;
&gt; 编码解码的过程大概是：输入token，经过矩阵编码得到词向量，而后解码再变成Token&#13;
&#13;
- CBOW和skip-gram都是**自监督**的方法，前者根据上下文中的词来预测目标词，后者相反&#13;
&#13;
## Transformer&#13;
### 注意力&#13;
&#13;
1. 查询、键和值矩阵：&#13;
&#13;
首先，输入被投影到查询（Query）、键（Key）和值（Value）矩阵上。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Transformer.html</guid><pubDate>Fri, 05 Jul 2024 12:26:26 +0000</pubDate></item><item><title>开始学习！</title><link>https://lqh-dlut.github.io/passion/post/kai-shi-xue-xi-%EF%BC%81.html</link><description>- [ ] [观看transformer视频](https://www.bilibili.com/video/BV1XH4y1T76e/?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&amp;vd_source=8c92169d4c84c919150f319298bb23db)&#13;
- [ ] 修图&#13;
- [ ] [codinguniversity学习](https://github.com/jwasham/coding-interview-university/blob/main/translations/README-cn.md#%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E5%88%B0%E5%AE%83)。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/kai-shi-xue-xi-%EF%BC%81.html</guid><pubDate>Fri, 05 Jul 2024 01:09:45 +0000</pubDate></item><item><title>Test for gmeek blog</title><link>https://lqh-dlut.github.io/passion/post/Test%20for%20gmeek%20blog.html</link><description>### _Hello World!               --24.7.5_     。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Test%20for%20gmeek%20blog.html</guid><pubDate>Fri, 05 Jul 2024 00:41:31 +0000</pubDate></item></channel></rss>
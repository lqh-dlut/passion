<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>StudyAllDay</title><link>https://lqh-dlut.github.io/passion</link><description>hello</description><copyright>StudyAllDay</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://lqh-dlut.github.io/passion</link></image><lastBuildDate>Mon, 03 Mar 2025 15:44:05 +0000</lastBuildDate><managingEditor>StudyAllDay</managingEditor><ttl>60</ttl><webMaster>StudyAllDay</webMaster><item><title>算法</title><link>https://lqh-dlut.github.io/passion/post/suan-fa.html</link><description>__
```
vec.append(n)
set.add(n)
```

### day1 2.26
**704 二分查找**： 注意只有一个元素的情况，循环应该是`while(right&gt;=left)`而不是`while(right&gt;left)`
**27 移除元素**： 原地算法O(1)空间复杂度，使用双指针算法
### day2 2.27
**977 有序数组的平方** 平方 `n**2`, 创建一个全 0 的数组 `new = [0] * len(nums)`

**209 长度最小的子数组** 正无穷 `n = float('inf')` 负无穷 `n = float('-inf')`； **滑动窗口（双指针）**的思路，核心是滑动窗口的**起始位置的移动**
`while(cs &gt;= target):
                min_len = min(min_len, fast-slow+1)
                cs -= nums[slow]
                slow += 1`

**59 螺旋矩阵** **定义边界**不断循环

### day3/4 2.28/3.2
**58 区间和** **前缀和** 前i个元素之和放在列表的第i个元素，注意前缀和区间
```
input = sys.stdin.read
data = input().split()
n = int(data[index])
```
**44 开发商购买土地** 
**todo：暴力优化**

**链表** 
`class ListNode: def __init__(self, val, next=None):
 self.val = val
 self.next = next
`
**常用dummy_head作为虚拟头结点，return dummy_head.next**

[**203 移除链表元素**](https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#_203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0) 三种方法：虚拟头结点，先处理头结点再在原链表上操作， **递归**

[**707 设计链表**](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html#_707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8)

**[206 反转链表](https://leetcode.cn/problems/reverse-linked-list/)**

**24 两两交换链表中的节点** 模拟交换的过程

**19 删除链表的倒数第N个节点** 快慢结点+虚拟头结点

[**160 链表相交**](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4) 
普通方法：求长度求差距再遍历 神奇方法：**等比例：解决特殊情况，利用A+B与B+A长度相等，相交结点后两链表长度相等，同时都为None也是相等**

[**142 环形链表II**](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii)
数学**分析**比较重要，利用快慢指针。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/suan-fa.html</guid><pubDate>Wed, 26 Feb 2025 16:15:53 +0000</pubDate></item><item><title>argoverse2数据preprocessed in DeMo</title><link>https://lqh-dlut.github.io/passion/post/argoverse2-shu-ju-preprocessed%20in%20DeMo.html</link><description>x_positions

含义：各代理（车辆/行人）在不同时间步的位置坐标（2D坐标，如[X, Y]）。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/argoverse2-shu-ju-preprocessed%20in%20DeMo.html</guid><pubDate>Tue, 25 Feb 2025 17:09:58 +0000</pubDate></item><item><title>服务器、cuda等注意事项</title><link>https://lqh-dlut.github.io/passion/post/fu-wu-qi-%E3%80%81cuda-deng-zhu-yi-shi-xiang.html</link><description>通过`ls /usr/local/cuda-xxxx  `判断是否安装了xxxx版本的cuda

e.g. : 以下代码将通过修改环境变量切换cuda版本，**临时配置 CUDA 12.6 的环境变量**

`export PATH=/usr/local/cuda-12.6/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda-12.6/lib64:$LD_LIBRARY_PATH`

&gt; 如果是长期使用，建议将配置写入 `~/.bashrc` 或 `~/.zshrc` 文件以实现永久生效。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/fu-wu-qi-%E3%80%81cuda-deng-zhu-yi-shi-xiang.html</guid><pubDate>Mon, 24 Feb 2025 13:29:37 +0000</pubDate></item><item><title>Argoverse Dataset</title><link>https://lqh-dlut.github.io/passion/post/Argoverse%20Dataset.html</link><description># Argoverse 2&#13;
&#13;
lidar, localization, cameras, calibration(校准)&#13;
&#13;
## Maps&#13;
&#13;
### Vector Map: 3D lane-level details(车道级细节)&#13;
&#13;
### Raster Map栅格地图: Ground Height &#13;
&#13;
## Sensor dataset&#13;
&#13;
for 3D scene perception algorithms&#13;
&#13;
data annotation注释 : amodal cuboid(长方体)&#13;
&#13;
## Lidar dataset&#13;
&#13;
not include imagery or 3D annotations, for lidar domain and point cloud forecasting or even the self-supervised learning and map automation&#13;
&#13;
## Motion forecasting dataset&#13;
&#13;
Each scenario is 11 seconds long and contains the 2D, birds-eye-view centroid and heading of each tracked object sampled at 10 Hz.&#13;
&#13;
special emphasis on kinematically and socially unusual behavior运动学和社会学上不寻常的行为&#13;
&#13;
## Map change dataset&#13;
&#13;
1。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Argoverse%20Dataset.html</guid><pubDate>Tue, 03 Dec 2024 16:15:35 +0000</pubDate></item><item><title>Python相关</title><link>https://lqh-dlut.github.io/passion/post/Python-xiang-guan.html</link><description>### open()函数&#13;
`open('path/file.format', encoding='格式[gbk]', '打开模式[r]')`&#13;
&#13;
#### 打开模式&#13;
```&#13;
# r 只读，默认模式，不存在则抛出错误&#13;
# rb 二进制打开只读&#13;
# r+ 读写，指针在文件开头&#13;
# w 只写，如果存在则覆盖原文件，否则创建新文件&#13;
# a 追加，如果存在则在结尾追加内容，否则创建新文件&#13;
```&#13;
&#13;
open后要`f.close()`，或 ` with open() as f:`&#13;
&#13;
操作之后read如果没有内容可能是**指针问题** read前把指针放在开始位置 ` f.seek(0) `&#13;
&#13;
### lambda&#13;
` fun1 = lambda x,y[参数]: x+y[执行内容]&#13;
&#13;
### copy 与 deepcopy&#13;
&#13;
赋值 是在同一个内存空间&#13;
copy（浅拷贝）只复制一层，子集内的是同一个内存空间&#13;
deepcopy深拷贝，完全重建一个集合&#13;
&#13;
### zip&#13;
同时处理若干个列表&#13;
&#13;
```&#13;
d = {}&#13;
 for n, s, b in zip(name, score, bonus):&#13;
    d[n] = s+b&#13;
```。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Python-xiang-guan.html</guid><pubDate>Thu, 19 Sep 2024 14:27:36 +0000</pubDate></item><item><title>LLM</title><link>https://lqh-dlut.github.io/passion/post/LLM.html</link><description>**RAG: retrieval-augmented generation检索增强生成**&#13;
&gt; 整合了从庞大知识库中检索到的相关信息，并以此为基础，指导大型语言模型生成更为精准的答案，从而显著提升了回答的准确性与深度&#13;
&#13;
1. 数据处理：清洗处理，转化格式，存数据库&#13;
2. 检索阶段：问题输入，数据库检索&#13;
3. 增强阶段：检索得到信息进行增强&#13;
4. 生成阶段：增强的信息输入到模型中，模型生成答案&#13;
&#13;
![image](https://github.com/user-attachments/assets/604a3396-1cc5-4087-9107-5e8b76d79be6)&#13;
&#13;
&#13;
### LangChain&#13;
&gt; 核心组件：Model I/O, Data connection, Chains, Memory, Agents, Callbacks&#13;
&#13;
### 大模型的开发&#13;
&gt; 通过 Prompt Engineering、数据工程、业务逻辑分解等手段来充分发挥大模型能力，适配应用任务&#13;
&#13;
### 基本概念&#13;
1. Prompt： 在自然语言吃力中是一个用于引导模型生成特定输出的输入文本或问题，替代给LLM的输入，而completion替代LLM输出&#13;
&#13;
2. Temperature：该参数用于控制LLM生成结果的随机性与创造性&#13;
&gt; 参数在0~1之间，越靠近0越保守，可预测；越接近1越随机，更有创意，多样化&#13;
&#13;
3. System Prompt：提升用户体验的一种策略，初始化设定，与User Prompt相区分。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/LLM.html</guid><pubDate>Wed, 04 Sep 2024 07:05:18 +0000</pubDate></item><item><title>Git 相关</title><link>https://lqh-dlut.github.io/passion/post/Git%20-xiang-guan.html</link><description>### 项目上传与更新&#13;
&gt; 添加内容到git暂存区&#13;
&#13;
```git add [./PATH]``` &#13;
&#13;
&gt; 撤销add的全部（部分）内容&#13;
&#13;
`git reset [PATH]`&#13;
&#13;
&gt; 查看git状态&#13;
&#13;
`git status`&#13;
&#13;
&gt; 从暂存区提交到本地仓库&#13;
&#13;
```&#13;
git commit -m 'comment'&#13;
```&#13;
&#13;
&gt; _如果只是对原来文件进行修改而没有新文件可以使用_&#13;
&#13;
```&#13;
git commit -a -m 'comment'&#13;
git commit -am 'comment'&#13;
```&#13;
&#13;
&gt; 撤销commit的内容&#13;
&#13;
```&#13;
git reset --soft HEAD~n  // 撤销n次commit&#13;
```&#13;
&#13;
&gt; 提交到远程仓库&#13;
&#13;
`git push &lt;远程仓库/默认origin&gt; &lt;本地分支/默认当前&gt;`&#13;
&#13;
&#13;
&gt; 查看git提交记录&#13;
&#13;
```&#13;
git log [branch]   // 显示分支的commit记录，其他分支会包括master中的&#13;
git log --oneline // 只显示一行内容&#13;
git log --all --graph --oneline --decorate  // 图形化显示分支&#13;
```&#13;
&#13;
&gt; 在远程github中更新的内容如何同步&#13;
&#13;
```&#13;
git fetch &lt;remote_repositories&gt; &lt;remote_branch&gt;:&lt;tmp branch name&gt;  // 下载远程仓库分支中最新的提交消息 通过 : 取别名&#13;
git diff &lt;branch&gt;&#13;
git merge &lt;branch&gt;&#13;
&#13;
git pull &lt;remote_repo&gt; &lt;remote_branch&gt; // 自动下载并合并到当前所在的本地仓库分支中，更方便但不如分布清晰&#13;
```&#13;
&#13;
### 项目与仓库的连接和重置&#13;
&#13;
&gt; 取消repos_name仓库连接&#13;
&#13;
`git remote remove repos_name`&#13;
&#13;
&gt; 清除git历史记录并初始化&#13;
&#13;
```&#13;
rm -rf .git&#13;
git init&#13;
```&#13;
&gt; 添加新的仓库，查看已连接的仓库&#13;
&#13;
```&#13;
git remote add name git@github.com:...&#13;
git remote -v&#13;
```&#13;
&#13;
_网络加速器，vpn等开启时可能会莫名出现报错如下：_&#13;
```&#13;
ssh: connect to host github.com port 22: Connection refused&#13;
fatal: Could not read from remote repository.&#13;
```&#13;
&#13;
### Git的一些概念&#13;
![image](https://github.com/user-attachments/assets/5962bdc3-6a99-4577-a331-82fde9ce0ff5)&#13;
&#13;
#### Branch 分支&#13;
```&#13;
git branch // 查看分支列表&#13;
git branch branch-name // 创建branch&#13;
git switch branch-name  // 切换分支&#13;
git merge branch-name  // 合并分支（到当前所在分支）&#13;
git branch -d branch-name // 删除已经合并的分支&#13;
git branch -D branch-name // 强制删除未合并分支&#13;
```&#13;
&#13;
&gt; 合并分支后还需要**手动**删除分支&#13;
&#13;
### Rebase &#13;
&#13;
&gt; rebase后跟的branch2是不变的，branch1跟在后面&#13;
&#13;
```&#13;
git switch branch1&#13;
git rebase branch2&#13;
```&#13;
&#13;
### Cherry-pick&#13;
&#13;
&gt; 将其他branch中的其中一次commit单独复刻到自己的branch中&#13;
&#13;
`git cherry-pick git-id`&#13;
&#13;
### .gitignore&#13;
&#13;
&#13;
&gt; 在gitignore文件中简化别名，git lg =&gt; git log --all --graph --oneline --decorate&#13;
&#13;
```&#13;
[alias]&#13;
    lg = log --all --graph --oneline --decorate&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Git%20-xiang-guan.html</guid><pubDate>Mon, 26 Aug 2024 05:14:45 +0000</pubDate></item><item><title>Redis</title><link>https://lqh-dlut.github.io/passion/post/Redis.html</link><description>## Redis&#13;
remote dictionary server 基于内存的数据存储系统（数据库，缓存，消息队列）&#13;
NoSQL&#13;
&gt;  磁盘IO导致的MySQL数据库性能瓶颈&#13;
&#13;
使用方式：&#13;
1. 命令行CLI&#13;
2. 代码API&#13;
3. 图形化GUI -&gt; RedisInsight&#13;
&#13;
windows下运行Redis&#13;
&lt;D:\app\redis&gt;redis-server.exe   // 服务器端&#13;
&lt;D:\app\redis&gt;redis-cli.exe         // 客户端&#13;
**redis-cli.exe --raw**                  // 显示原始数据（否则中文以二进制显示）&#13;
&#13;
### STRING&#13;
SET key value&#13;
**SETEX key time value  //设置带过期时间的键&#13;
SETNX key value   //只有不存在时候才设置成功**&#13;
GET key&#13;
DEL key&#13;
EXISTS key&#13;
**KEYS *                  //查找全部键**&#13;
KEYS key&#13;
KEYS *st               //查找全部以st结尾的键&#13;
FLUSHALL            //全部数据删除&#13;
**EXPIRE key time  //倒计时**&#13;
TTL key               //查看过期时间&#13;
&#13;
&#13;
&#13;
### List&#13;
LPUSH list key1 key2 key3  //添加到list头部，一次性可添加多个，注意这样加的顺序是key3在头部&#13;
RPUSH list key //尾部&#13;
&#13;
&gt; 列表从左到右 0,1,2,3... L可以理解为left，R是right&#13;
&#13;
LRANGE list 0 -1  //输出列表元素，0 -1表示从头到尾&#13;
LPOP/RPOP list count //从头/尾删除count个元素&#13;
LTRIM list start end  //删除范围之外的元素&#13;
LLEN list //length&#13;
RPOPLPUSH //最简单的先进先出的队列&#13;
&#13;
### SET&#13;
&gt; 无序集合，元素唯一不可以重复，没有顺序&#13;
&#13;
SADD set key     // 添加&#13;
SMEMBERS set  // 输出&#13;
SISMEMBER set key //判断是否是集合中元素&#13;
SREM set key //删除&#13;
SINTER set1 set2 ... //输出集合的交集&#13;
SUNION // 并集&#13;
&#13;
### SortedSet (ZSet)&#13;
&gt; 有序集合，每一个唯一的元素关联一个不唯一的可重复的分数，按分数**从小到大**排序&#13;
&#13;
ZADD zset score1 key1 score2 key2 &#13;
ZREM zset key&#13;
ZRANGE zset start end [WITHSCORES]  //（带分数的）输出 &#13;
ZCARD zset // 成员数量&#13;
ZSCORE zset key // 输出元素对应的分数&#13;
ZRANK zset key // 输出元素分数的排名（从小到大的排名）&#13;
ZREVRANK // 从大到小的排名&#13;
ZCOUNT zset min max // 范围内的成员数量&#13;
&#13;
&#13;
### HASH&#13;
&#13;
HSET hash key val&#13;
HGET hash key&#13;
HGETALL hash // 成对出现的哈希对&#13;
HDEL hash key&#13;
HEXISTS hash key&#13;
&#13;
&#13;
### STREAM&#13;
XADD stream *  field message // * 表示随机消息id，id可自定义[time-number] 返回的是消息id的值&#13;
XLEN stream &#13;
XRANGE stream - +  // - +代表的是从头到尾，可数字范围&#13;
XDEL stream id&#13;
XREAD COUNT num BLOCK millisecond STREAMS stream start   //num代表返回的条目数量，BLOCK是阻塞多少毫秒，start是开始的序列号&#13;
XREAD COUNT 3 BLOCK 10000  STREAMS streamtest $   // **用' $ '表示从现在开始接收到的新消息**&#13;
&#13;
&gt; consumer group 消费者组&#13;
&#13;
XGROUP CREAT stream group id MKSTREAM  // 创建消费者组 id表示该消费者组从何处开始读取信息，可省略使用SETID命令单独设置，而MKSTREAM表示若不存在则新创建一个stream&#13;
XGROUP CREATE/DELCONSUMER stream group consumer  // 加入/删除消费者&#13;
XREADGROUP GROUP group consumer COUNT num BLOCK time STREAMS stream id  // 为consumer读取消息，id为0表示从一开始开始读取，**id为' &gt; '表示读取最新的消息**&#13;
&#13;
### GEO 地理位置&#13;
&#13;
GEOADD key longitude latitude member ...   // 添加member经纬信息&#13;
GEOPOS key member  // 显示位置信息&#13;
GEODIST key mem1 mem2 [KM]  [WITHDIST] [WITHCOORD] // 计算量地址的直线距离，默认是米为单位，添加KM转换&#13;
GEORESEARCH key FROMMEMBER mem1 BYRADIUS/ BYBOX num [KM] // 圆形矩形范围内的成员 withdist,withcoord表示附上距离，坐标&#13;
&#13;
### HyperLoglog 估算基数&#13;
&#13;
&gt; 基数：不重复数，原理使用随机算法计算，精度没那么高但性能好，适合**大量的不需要高精度的数据**，e.g.浏览量&#13;
&#13;
PFADD cardinal key1 key2 ...     // 添加基数 &#13;
PFCOUNT cardinal&#13;
PFMERGE result cardinal1 cardinal2  //合并到result中&#13;
&#13;
### Bitmap 位图&#13;
&gt; 字符串类型的扩展，0和1表示一个bit数组&#13;
&#13;
SETBIT bitmap index val&#13;
SET bitmap '11000101' / '\xC5'   //单独和完整设置bitmap的值，可利用二进制或' \x '转为十六进制方便&#13;
BITCOUNT bitmap start end  //返回bitmap中1的个数&#13;
BITPOS bitmap 0/1 start end  // 出现的第一个0/1的位置 &#13;
&#13;
### Bitfield 位域&#13;
BITFIELD fieldid set [u8/i8/...] #index key&#13;
BITFIELD fieldid get [format] #index&#13;
BITFIELD fieldid INCRBY [u8/i8/...] #index key&#13;
&#13;
### 事务&#13;
MULTI ... EXEC &#13;
&gt; 使用队列缓存事务中的命令，如果有命令出现错误，不影响其他正确的命令，其他用户的命令不会插入队列中&#13;
&#13;
&gt; 通过conf配置文件实现主从复制&#13;
&#13;
### sentinel 哨兵结点&#13;
&#13;
&gt; 监控，通知，故障转移&#13;
&#13;
哨兵结点本身也是单节点，一般使用三个哨兵结点实现高可用，通过选举的方式选择新的主节点&#13;
哨兵之间通信使用的是发布/订阅功能&#13;
&#13;
 。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Redis.html</guid><pubDate>Tue, 20 Aug 2024 09:54:12 +0000</pubDate></item><item><title>三种树</title><link>https://lqh-dlut.github.io/passion/post/san-zhong-shu.html</link><description>## 红黑树&#13;
**自平衡的二叉搜索树，通过染色，解决AVL树频繁的旋转的问题（染色时复小于旋转）**&#13;
&gt; 二叉搜索树：左子树所有值小于等于根节点，右子树相反；左右子树也是二叉搜索树&#13;
&gt; AVL（自平衡二叉搜索树）：解决二叉搜索树在插入删除操作时可能会导致的O(n)操作，使得操作时复全在O(logn)&#13;
&#13;
**最坏情况下，红黑树的黑色高度至多是红色高度的两倍**&#13;
### 红黑树的规则&#13;
1. 非黑即红&#13;
2. 根节点黑&#13;
3. 叶结点黑 _（全是空节点NULL黑色节点）_&#13;
4. 红点黑父子（不红红）&#13;
5. 任一结点到叶子结点路径上黑色结点的个数相同（黑路同）&#13;
&#13;
左旋转伪代码&#13;
```&#13;
Leftrotation(X)&#13;
#初始Y是X的右节点&#13;
    #确立旋转后X的右节点与X的关系&#13;
    X.right = Y.left  #Y左移到X右，确立子树关系&#13;
    if(Y.left != NIL) #Y有左节点或左子树&#13;
        Y.left.parent = X #Y左父结点指针指向X，确立父结点关系&#13;
    &#13;
    #确立旋转后Y的父结点与Y之间的关系&#13;
    Y.parent = X.parent #确定Y的父结点&#13;
    if(X.parent == NIL) #如果X为根节点&#13;
        Root = Y&#13;
    else if(X.parent.left == X)&#13;
        X.parent.left = Y&#13;
    else if(X.parent.right == X)&#13;
        X.parent.left = Y&#13;
    &#13;
    #确立旋转后X和Y之间的关系&#13;
    Y.left = X&#13;
    X.parent = Y&#13;
```&#13;
&#13;
### 插入的调整方法&#13;
插入的是红色结点，容易破坏的是不红红的性质&#13;
1. 叔红：祖父染红，父叔染黑&#13;
&#13;
2. 叔黑&#13;
&#13;
- 同侧：父染黑，祖父染红，以父为基点进行右（左）旋&#13;
- 异侧：父左（右）旋，子染黑，祖父染红，祖父右（左）旋&#13;
&#13;
### 删除的调整方法&#13;
&gt; 双黑节点：所有经过他的路径都会少一个黑节点&#13;
&#13;
1. 没有孩子节点&#13;
- 红色：直接删除&#13;
- 黑色：&#13;
黑兄弟没有孩子：删除后，父染黑，兄弟红&#13;
黑兄弟只有左孩子：删节点，兄弟左孩子染父色，父染黑，兄弟右旋，父左旋&#13;
黑兄弟只有右孩子：删节点，兄弟染父色，父染黑，父左旋&#13;
黑兄弟左右孩子都红色：删节点，兄弟染父色，父染黑，兄弟右孩子染黑，父左旋&#13;
红兄弟：删节点，兄弟染黑，兄弟左孩子染红，父左旋&#13;
&#13;
2. 只有左（右）结点&#13;
&gt; 由于红黑树的性质，红结点不可能只有左（右）子树，只有左右结点的情况只能是父（要删除的结点）黑子红&#13;
&#13;
孩子的值替换，颜色不变（黑）&#13;
&#13;
3. 有双孩子，中序后继或前驱替换，再判断&#13;
&gt; 一棵全黑的树，则兄弟染红，替换后继的值，前驱节点变红&#13;
&#13;
&#13;
## b树&#13;
**多路平衡搜索树，阶数m为结点孩子个数最大值，为了将大型文件存储在磁盘中，减少访问磁盘的次数**&#13;
### b树的规则&#13;
1. 每个结点最多有m棵子树，即m-1个关键字（m叉树）&#13;
2. 根结点至少两个分支，终端结点至少两个关键字，非根非叶结点至少有ceil(m/2)个分支ceil代表向上取整&#13;
3. 每个结点结构，m个指针，一个关键字个数n，m-1个关键字数据&#13;
4. 各个关键字不相同且左小右大排列&#13;
5. 叶子结点在同一层，代表查询失败的位置&#13;
6. 数据分布在不同层级，查找的时间不稳定&#13;
&#13;
&#13;
&gt; 最低层的非叶结点为终端结点&#13;
&#13;
**b树插入关键是结点的拆分，删除关键是借兄弟借父母**&#13;
&#13;
## b+树&#13;
是b树的变体，在I/O方面更加优秀&#13;
&#13;
### b+树规则&#13;
1. m个关键字对应m个分支&#13;
2. 关键字在不同结点之间可以重复&#13;
3. 最低层的叶子结点包含所有关键字，和指向数据的指针（只有叶子结点有指针）&#13;
4. 叶子节点之间通过指针相互链接&#13;
&#13;
**b树不支持顺序查找，b+支持；b树查询速度不稳定，可在任一层级查到，b+树查询速度稳定，都在叶子结点层查到**&#13;
。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/san-zhong-shu.html</guid><pubDate>Wed, 31 Jul 2024 10:36:44 +0000</pubDate></item><item><title>排序算法</title><link>https://lqh-dlut.github.io/passion/post/pai-xu-suan-fa.html</link><description># 排序算法（内部排序，使用内存）&#13;
![image](https://github.com/user-attachments/assets/d0194212-7172-4f6a-ad51-f999fc91a6b1)&#13;
## 交换排序&#13;
### 快速排序&#13;
不稳定&#13;
&#13;
1. 选取一个基准pivot，一般为最左元素&#13;
2. 从右往左找到比pivot大的值，右值放到左指针位置&#13;
3. 接着从左往右找到比其小的值，左值放到右指针位置&#13;
4. 重复2,3步骤（为一个循环），直到两指针重合，pivot值放在重合位置，此时基准位置确定&#13;
5. 递归左右集合至排序完成&#13;
&#13;
&gt; 平均与最好时间复杂度为O(nlogn)，空间复杂度为O(1)&#13;
&gt; 为防止出现最坏情况O(n^2)退化为冒泡排序，会采用随机取pivot或三数取中&#13;
&#13;
### 冒泡排序&#13;
**稳定排序**&#13;
&#13;
比较两个元素，使得一轮后最大的元素在最右端，不断重复即可&#13;
&gt; 反序-&gt;最差时复O(n^2)，平均时复n^2，正序-&gt;最好时复O(n)&#13;
&#13;
## 选择排序&#13;
### 简单选择排序&#13;
不稳定&#13;
&#13;
每次选择最小（最大）的元素，放在最后，重复至排序完成&#13;
&#13;
&gt; 时复O(n^2)&#13;
&#13;
### 堆排序&#13;
不稳定&#13;
&#13;
大顶堆输出升序，小顶堆输出降序序列&#13;
&#13;
1. 将根节点（最大最小值）与最后一个叶结点交换，输出该最值&#13;
2. 去除最值后重新构成大（小）根堆&#13;
3. 重复步骤输出全部值&#13;
&#13;
&gt; 时间复杂度最好最坏都是O(nlogn)，其中构建堆时间复杂度O(n)&#13;
&#13;
&#13;
## 插入排序&#13;
### 直接插入排序&#13;
**稳定排序**&#13;
&#13;
&gt; 最好O(n)，最坏或平均O(n^2)&#13;
&#13;
### 希尔排序&#13;
不稳定&#13;
&#13;
间隔不断减小的插入排序&#13;
&#13;
&gt; 时间复杂度最差O(n^2)，最好O(nlogn)，平均不定&#13;
&#13;
## 归并排序&#13;
**稳定排序**&#13;
&#13;
1. 拆分成一个元素一个元素的&#13;
2. 两两合并&#13;
&#13;
&gt; 最差最好平均都为O(nlogn)，**空间复杂度为O(n)**&#13;
&#13;
。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/pai-xu-suan-fa.html</guid><pubDate>Thu, 25 Jul 2024 03:09:52 +0000</pubDate></item><item><title>Flask</title><link>https://lqh-dlut.github.io/passion/post/Flask.html</link><description>###视图函数&#13;
```python&#13;
from markupsafe import escape&#13;
&#13;
@app.route('/user/&lt;name&gt;')&#13;
def user_page(name):&#13;
    return f'User: {escape(name)}'&#13;
```&#13;
&#13;
&gt; 注意 用户输入的数据会包含恶意代码，所以不能直接作为响应返回，需要使用 MarkupSafe（Flask 的依赖之一）提供的 escape() 函数对 name 变量进行转义处理，比如把 &lt; 转换成 &amp;lt;。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Flask.html</guid><pubDate>Mon, 08 Jul 2024 13:49:18 +0000</pubDate></item><item><title>Transformer</title><link>https://lqh-dlut.github.io/passion/post/Transformer.html</link><description>- 图像识别 -&gt; **CNN卷积神经网络**&#13;
- NLP自然语言处理 -&gt; **RNN循环神经网络** 解决了seq2seq问题 输入输出语句长短不同&#13;
- Transformer与RNN都保留了**编码和解码**的结构&#13;
## 词嵌入&#13;
- “码”指的大概是 把语言中的形式的不同去除后，剩下的单纯的**语义关系**，其标准有：&#13;
&#13;
1. 数字化&#13;
2. 数值体现语义之间的相对关系&#13;
&#13;
&#13;
&gt; 对token进行数字化的两种极端情况，上述的第一点标准都能实现，但第二点都是极端的错误：&#13;
&#13;
- **tokenizer标记器**（分词器）：每一个token都是不同的ID（一维）&#13;
- **onehot独热编码**：每一个token是二级制中的每一位（n维）&#13;
&#13;
&gt; 矩阵乘法实现词嵌入，编码进潜空间，解码出潜空间&#13;
&#13;
- **潜空间**：没有形式上差别的语义空间，是连续的，因此遇到陌生的情况也能找到对应的值&#13;
&#13;
## Word2Vec（词典）&#13;
&#13;
&gt; 一般的机器学习目标：得到一个模型，模型能够完成任务；**Word2Vec**得到的是嵌入矩阵，得到的是模型的参数&#13;
&#13;
- Word2Vec**不需要激活函数**，隐藏层输出层的神经元做的就是向量求和与分解，没有非线性的需求&#13;
&#13;
&gt; 编码解码的过程大概是：输入token，经过矩阵编码得到词向量，而后解码再变成Token&#13;
&#13;
- CBOW和skip-gram都是**自监督**的方法，前者根据上下文中的词来预测目标词，后者相反&#13;
&#13;
## Transformer&#13;
### 注意力&#13;
&#13;
1. 查询、键和值矩阵：&#13;
&#13;
首先，输入被投影到查询（Query）、键（Key）和值（Value）矩阵上。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Transformer.html</guid><pubDate>Fri, 05 Jul 2024 12:26:26 +0000</pubDate></item><item><title>开始学习！</title><link>https://lqh-dlut.github.io/passion/post/kai-shi-xue-xi-%EF%BC%81.html</link><description>- [ ] [观看transformer视频](https://www.bilibili.com/video/BV1XH4y1T76e/?spm_id_from=333.788.top_right_bar_window_default_collection.content.click&amp;vd_source=8c92169d4c84c919150f319298bb23db)&#13;
- [ ] 修图&#13;
- [ ] [codinguniversity学习](https://github.com/jwasham/coding-interview-university/blob/main/translations/README-cn.md#%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E5%88%B0%E5%AE%83)。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/kai-shi-xue-xi-%EF%BC%81.html</guid><pubDate>Fri, 05 Jul 2024 01:09:45 +0000</pubDate></item><item><title>Test for gmeek blog</title><link>https://lqh-dlut.github.io/passion/post/Test%20for%20gmeek%20blog.html</link><description>### _Hello World!               --24.7.5_     。</description><guid isPermaLink="true">https://lqh-dlut.github.io/passion/post/Test%20for%20gmeek%20blog.html</guid><pubDate>Fri, 05 Jul 2024 00:41:31 +0000</pubDate></item></channel></rss>